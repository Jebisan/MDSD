/*
 * generated by Xtext 2.16.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.pycom.Actuator;
import xtext.pycom.Board;
import xtext.pycom.BoardMember;
import xtext.pycom.Communication;
import xtext.pycom.CommunicationType;
import xtext.pycom.ComparisonExp;
import xtext.pycom.Condition;
import xtext.pycom.ConditionalAction;
import xtext.pycom.Connection;
import xtext.pycom.Expression;
import xtext.pycom.Function;
import xtext.pycom.Host;
import xtext.pycom.Import;
import xtext.pycom.Library;
import xtext.pycom.LogicExp;
import xtext.pycom.ModuleName;
import xtext.pycom.ModuleType;
import xtext.pycom.ParameterType;
import xtext.pycom.Pin;
import xtext.pycom.PinName;
import xtext.pycom.PycomPackage;
import xtext.pycom.Sensor;
import xtext.pycom.Server;
import xtext.services.PycomGrammarAccess;

@SuppressWarnings("all")
public class PycomSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PycomGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PycomPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PycomPackage.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case PycomPackage.BOARD:
				sequence_Board(context, (Board) semanticObject); 
				return; 
			case PycomPackage.BOARD_MEMBER:
				sequence_BoardMember(context, (BoardMember) semanticObject); 
				return; 
			case PycomPackage.BOOLEAN:
				sequence_Boolean(context, (xtext.pycom.Boolean) semanticObject); 
				return; 
			case PycomPackage.COMMUNICATION:
				sequence_Communication(context, (Communication) semanticObject); 
				return; 
			case PycomPackage.COMMUNICATION_TYPE:
				sequence_CommunicationType(context, (CommunicationType) semanticObject); 
				return; 
			case PycomPackage.COMPARISON_EXP:
				sequence_ComparisonExp(context, (ComparisonExp) semanticObject); 
				return; 
			case PycomPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case PycomPackage.CONDITIONAL_ACTION:
				sequence_ConditionalAction(context, (ConditionalAction) semanticObject); 
				return; 
			case PycomPackage.CONNECTION:
				sequence_Connection(context, (Connection) semanticObject); 
				return; 
			case PycomPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case PycomPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case PycomPackage.HOST:
				sequence_Host(context, (Host) semanticObject); 
				return; 
			case PycomPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case PycomPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case PycomPackage.LOGIC_EXP:
				sequence_LogicExp(context, (LogicExp) semanticObject); 
				return; 
			case PycomPackage.MODULE_NAME:
				sequence_ModuleName(context, (ModuleName) semanticObject); 
				return; 
			case PycomPackage.MODULE_TYPE:
				sequence_ModuleType(context, (ModuleType) semanticObject); 
				return; 
			case PycomPackage.PARAMETER_TYPE:
				sequence_ParameterType(context, (ParameterType) semanticObject); 
				return; 
			case PycomPackage.PIN:
				sequence_Pin(context, (Pin) semanticObject); 
				return; 
			case PycomPackage.PIN_NAME:
				sequence_PinName(context, (PinName) semanticObject); 
				return; 
			case PycomPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case PycomPackage.SERVER:
				sequence_Server(context, (Server) semanticObject); 
				return; 
			case PycomPackage.SYSTEM:
				sequence_System(context, (xtext.pycom.System) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BoardMember returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (typeName=ModuleType actuatorName=ModuleName pins=Pin?)
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoardMember returns BoardMember
	 *
	 * Constraint:
	 *     boardMember=Sensor
	 */
	protected void sequence_BoardMember(ISerializationContext context, BoardMember semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.BOARD_MEMBER__BOARD_MEMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.BOARD_MEMBER__BOARD_MEMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoardMemberAccess().getBoardMemberSensorParserRuleCall_0_0(), semanticObject.getBoardMember());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Board returns Board
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         boardType=ID 
	 *         communicationRate=INT 
	 *         library+=[Library|ID]? 
	 *         library+=[Library|ID]* 
	 *         boardMembers+=BoardMember*
	 *     )
	 */
	protected void sequence_Board(ISerializationContext context, Board semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Boolean(ISerializationContext context, xtext.pycom.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommunicationType returns CommunicationType
	 *
	 * Constraint:
	 *     ((name='WiFi' ssid=STRING password=STRING) | name='Bluetooth' | name='SigFox')
	 */
	protected void sequence_CommunicationType(ISerializationContext context, CommunicationType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoardMember returns Communication
	 *     Communication returns Communication
	 *
	 * Constraint:
	 *     type=CommunicationType
	 */
	protected void sequence_Communication(ISerializationContext context, Communication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.COMMUNICATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.COMMUNICATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommunicationAccess().getTypeCommunicationTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComparisonExp returns ComparisonExp
	 *
	 * Constraint:
	 *     (left=Expression op=Operator right=Expression)
	 */
	protected void sequence_ComparisonExp(ISerializationContext context, ComparisonExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.COMPARISON_EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.COMPARISON_EXP__LEFT));
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.COMPARISON_EXP__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.COMPARISON_EXP__OP));
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.COMPARISON_EXP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.COMPARISON_EXP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpAccess().getLeftExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonExpAccess().getOpOperatorParserRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonExpAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (logicEx=LogicExp | (logicEx=LogicExp operator='&&' nestedCondition=Condition) | (logicEx=LogicExp operator='||' nestedCondition=Condition))
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalAction returns ConditionalAction
	 *     ExpMember returns ConditionalAction
	 *
	 * Constraint:
	 *     (type='if' condition=Condition ExpMembers+=ExpMember*)
	 */
	protected void sequence_ConditionalAction(ISerializationContext context, ConditionalAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Connection returns Connection
	 *
	 * Constraint:
	 *     (host=Host portnumber=INT)
	 */
	protected void sequence_Connection(ISerializationContext context, Connection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.CONNECTION__HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.CONNECTION__HOST));
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.CONNECTION__PORTNUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.CONNECTION__PORTNUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectionAccess().getHostHostParserRuleCall_0_0(), semanticObject.getHost());
		feeder.accept(grammarAccess.getConnectionAccess().getPortnumberINTTerminalRuleCall_2_0(), semanticObject.getPortnumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (outputValue=INT | outputfunction=Function)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpMember returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (board=[Board|ID] functionName=[Import|ID] pins+=Pin?)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Host returns Host
	 *
	 * Constraint:
	 *     (ipAdr=Ipaddress | website=STRING)
	 */
	protected void sequence_Host(ISerializationContext context, Host semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (name=ID parameter+=ParameterType? parameter+=ParameterType* path=STRING)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (name=ID imports+=Import*)
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicExp returns LogicExp
	 *
	 * Constraint:
	 *     (boolVal=Boolean | compExp=ComparisonExp)
	 */
	protected void sequence_LogicExp(ISerializationContext context, LogicExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleName returns ModuleName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ModuleName(ISerializationContext context, ModuleName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.MODULE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.MODULE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleType returns ModuleType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ModuleType(ISerializationContext context, ModuleType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.MODULE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.MODULE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleTypeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterType returns ParameterType
	 *
	 * Constraint:
	 *     (number=INT | text=STRING)
	 */
	protected void sequence_ParameterType(ISerializationContext context, ParameterType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PinName returns PinName
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_PinName(ISerializationContext context, PinName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.PIN_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.PIN_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPinNameAccess().getNameSTRINGTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns Pin
	 *
	 * Constraint:
	 *     (power=PinName input=PinName)
	 */
	protected void sequence_Pin(ISerializationContext context, Pin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.PIN__POWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.PIN__POWER));
			if (transientValues.isValueTransient(semanticObject, PycomPackage.Literals.PIN__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PycomPackage.Literals.PIN__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPinAccess().getPowerPinNameParserRuleCall_0_0(), semanticObject.getPower());
		feeder.accept(grammarAccess.getPinAccess().getInputPinNameParserRuleCall_2_0(), semanticObject.getInput());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (typeName=ModuleType sensorName=ModuleName pins=Pin?)
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Server returns Server
	 *
	 * Constraint:
	 *     (name=ID conn=Connection exps+=ConditionalAction*)
	 */
	protected void sequence_Server(ISerializationContext context, Server semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (
	 *         (libraries+=Library+ ((imports+=Import+ servers+=Server+) | servers+=Server+)) | 
	 *         (((libraries+=Library+ imports+=Import+) | imports+=Import+)? boards+=Board+ servers+=Server+) | 
	 *         (imports+=Import+ servers+=Server+) | 
	 *         servers+=Server+
	 *     )?
	 */
	protected void sequence_System(ISerializationContext context, xtext.pycom.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
