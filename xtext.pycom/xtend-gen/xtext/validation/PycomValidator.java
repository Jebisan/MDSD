/**
 * generated by Xtext 2.16.0
 */
package xtext.validation;

import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import xtext.pycom.Board;
import xtext.pycom.Connection;
import xtext.pycom.Host;
import xtext.pycom.PycomPackage;
import xtext.pycom.Sensor;
import xtext.validation.AbstractPycomValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class PycomValidator extends AbstractPycomValidator {
  public static final String INVALID_NAME = "invalidName";
  
  public static final String INVALID_TYPENAME = "invalidTypeName";
  
  public static final String INVALID_PORTNUMBER = "invalidPortnumber";
  
  public static final String INVALID_RATE = "InvalidCommunicationRate";
  
  @Check
  public void checkSensorTypeIsUpperCase(final Sensor sensor) {
    boolean _isUpperCase = Character.isUpperCase(sensor.getTypeName().getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Sensor type names should be uppercase!", PycomPackage.Literals.SENSOR__TYPE_NAME, PycomValidator.INVALID_TYPENAME);
    }
  }
  
  @Check
  public void checkSensorNameIsLowerCase(final Sensor sensor) {
    boolean _isLowerCase = Character.isLowerCase(sensor.getSensorName().getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Sensor names should be lowercase!", PycomPackage.Literals.SENSOR__SENSOR_NAME, PycomValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkIfthereAreBoards(final xtext.pycom.System system) {
    int _length = ((Object[])Conversions.unwrapArray(system.getBoards(), Object.class)).length;
    boolean _lessEqualsThan = (_length <= 0);
    if (_lessEqualsThan) {
      this.error("There should be at least one board in the program", PycomPackage.Literals.SYSTEM__BOARDS, "No boards found");
    }
  }
  
  @Check
  public void checkIfthereAreServers(final xtext.pycom.System system) {
    int _length = ((Object[])Conversions.unwrapArray(system.getServers(), Object.class)).length;
    boolean _lessEqualsThan = (_length <= 0);
    if (_lessEqualsThan) {
      this.error("There should be at least one server in the program", PycomPackage.Literals.SYSTEM__SERVERS, "No server found");
    }
  }
  
  @Check
  public void portnumberWithinRange(final Connection con) {
    if (((con.getPortnumber() <= 1024) || (con.getPortnumber() >= 65535))) {
      this.error("Port number should be between 1024 and 65535", PycomPackage.Literals.CONNECTION__PORTNUMBER, PycomValidator.INVALID_PORTNUMBER);
    }
  }
  
  @Check
  public void websiteIsValid(final Host host) {
    boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(host.getWebsite());
    boolean _not = (!_isNullOrEmpty);
    if (_not) {
      boolean _startsWith = host.getWebsite().startsWith("http://");
      boolean _not_1 = (!_startsWith);
      if (_not_1) {
        boolean _startsWith_1 = host.getWebsite().startsWith("https://");
        boolean _not_2 = (!_startsWith_1);
        if (_not_2) {
          this.error("Not a valid HTTP server. Should be either HTTP or HTTPS", PycomPackage.Literals.HOST__WEBSITE, "invalid web address");
        }
      }
    }
  }
  
  @Check
  public void rateIsLargerThan0(final Board board) {
    int _communicationRate = board.getCommunicationRate();
    boolean _lessThan = (_communicationRate < 1);
    if (_lessThan) {
      this.error("The rate should be larger than 0!", PycomPackage.Literals.BOARD__COMMUNICATION_RATE, PycomValidator.INVALID_RATE);
    }
  }
}
